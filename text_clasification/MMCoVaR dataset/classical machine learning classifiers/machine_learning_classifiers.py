{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "<>:118: SyntaxWarning: invalid escape sequence '\\s'\n",
      "<>:118: SyntaxWarning: invalid escape sequence '\\s'\n",
      "C:\\Users\\Lukag\\AppData\\Local\\Temp\\ipykernel_5620\\3988082522.py:118: SyntaxWarning: invalid escape sequence '\\s'\n",
      "  text = re.sub('\\s+', ' ', text)\n",
      "[nltk_data] Downloading package punkt to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package punkt is already up-to-date!\n",
      "[nltk_data] Downloading package averaged_perceptron_tagger to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package averaged_perceptron_tagger is already up-to-\n",
      "[nltk_data]       date!\n",
      "[nltk_data] Downloading package wordnet to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package wordnet is already up-to-date!\n",
      "[nltk_data] Downloading package stopwords to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package stopwords is already up-to-date!\n",
      "[nltk_data] Downloading package punkt_tab to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package punkt_tab is already up-to-date!\n",
      "[nltk_data] Downloading package averaged_perceptron_tagger_eng to\n",
      "[nltk_data]     C:\\Users\\Lukag\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package averaged_perceptron_tagger_eng is already up-to-\n",
      "[nltk_data]       date!\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Size of data:  (677, 2)\n",
      "                                                text  target\n",
      "0  Article courtesy of Kenneth Kwok Co-President ...       1\n",
      "1  The FDA has quickly given the OK to the second...       1\n",
      "2  Tesla will temporarily shut down its car manuf...       1\n",
      "3  USA TODAY\\n\\nAs the novel coronavirus spreads ...       1\n",
      "4  Is it safe for me to go outside?\\n\\nFor most p...       1\n",
      "852.6873156342183\n",
      "354.4230769230769\n",
      "5243.563421828909\n",
      "2229.2781065088757\n",
      "443.27433628318585\n",
      "216.62130177514794\n"
     ]
    },
    {
     "data": {
      "image/png": "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KzExUf/3f/+nHTt2XLDd+fgkXTBGAMDVY+YHAK4Dvr6+uv3227V+/XrZ7XYrGTivbdu2eu211yQ5v9y0WbNmSk5O1syZM5Wbm6uOHTvqyy+/1Jw5c9SjRw/dddddlzz2wIED9eabb+pPf/qTsrKyFB4errlz56pq1apO7VatWqXBgwerV69euvnmm3X27FnNnTvX+oF/KREREZowYYIOHDigm2++We+//762bdummTNnqkqVKpKkvn37auHChXr00Ue1evVqtWvXTufOndM333yjhQsXWu8ouhKxsbGaPn26xo8frwYNGigkJMRaSOF8YrNnzx699NJL1j533nmnPv30U9ntdus9PNLPidHf//53de3aVTExMerXr59+85vf6MiRI1q9erUCAgK0dOlSSdLLL7+s1atXq3Xr1ho4cKCaNGmi48ePa8uWLfrss890/PhxST/PJgUGBmrGjBmqUaOGqlWrptatW7vkuSYAwP/PrWvNAQAsI0eONJJM27ZtS9V9+OGHRpKpUaOGOXv2rFNdcXGxGTt2rImOjjZVqlQxkZGRZuTIkaawsNCpXd26dU23bt3KPPbBgwfN/fffb6pWrWpq1aplnnjiCZOenu601PV3331n+vfvb+rXr2/8/PxMUFCQueuuu8xnn312yXPr2LGjiYmJMZs3bzZxcXHGz8/P1K1b17z55pul2p45c8ZMmDDBxMTEGLvdbmrWrGliY2PN2LFjTV5entVOkklJSbnksc/Lzs423bp1MzVq1DCSSi17HRISYiSZnJwcq2zDhg1GkunQoUOZfW7dutX07NnTBAcHG7vdburWrWsefPBBs3LlSqd2OTk5JiUlxURGRpoqVaqYsLAw06VLFzNz5kyndh999JFp0qSJ8fHxYdlrAKgANmN+8fpqAAAqQKdOnfTDDz+UeesXAADXCs/8AAAAAPAIJD8AAAAAPALJDwAAAACPQPIDXMDs2bNls9m0efNmd4cC3PDWrFnD8z6ApOeff/6K3+l0/rp04MAB1wb1CwcOHJDNZtPs2bMr7BiAO5H8oNI5f3EoaxsxYoS7w3Myf/78Uu9nqQi7du3S888/X6EXTACozHbu3KmHHnpIv/nNb2S32xUREaGkpCTt3LnT3aG5xfV0XTl69Kief/55bdu2zd2h4AbAe35QaY0bN67U+zFuvfVWN0VTtvnz52vHjh0aNmxYhR5n165dGjt2rDp16qR69epV6LEAoLL58MMP1adPHwUFBWnAgAGKjo7WgQMH9M477+iDDz7QggUL9Pvf//6y+nruueeu+A9xffv2Ve/evWW3269of1e6nq4rR48e1dixY1WvXj01b97crbHg+kfyg0qra9euV/wyRAAAJOk///mP+vbtq5tuuknr1q1T7dq1rbonnnhCHTp0UN++ffX111/rpptuumA/BQUFqlatmnx8fOTjc2U/v7y9veXt7X1F+wL4Gbe9weMcPHhQjz/+uG655Rb5+/srODhYvXr1uqyp+59++kl33HGH6tSpoz179kiSioqKNGbMGDVo0EB2u12RkZF6+umnVVRUdNG+OnXqpE8++UQHDx60bsv75V/PLqff5ORk+fn5affu3U59JyQkqGbNmjp69Khmz56tXr16SZLuuusu61hr1qyRJG3evFkJCQmqVauW/P39FR0drf79+1/GSAJA5fe3v/1Np06d0syZM50SH0mqVauW3nrrLRUUFOiVV16xys8/17Nr1y798Y9/VM2aNdW+fXunul86ffq0hg4dqlq1aqlGjRq6//77deTIEdlsNj3//PNWu7Ke+alXr57uvfdebdiwQXfccYf8/Px000036d1333U6xvHjx/WXv/xFTZs2VfXq1RUQEKCuXbvqq6++KveYXOq6IkmffvqpOnTooGrVqqlGjRrq1q2b0y2Cq1atkpeXl0aPHu3U9/z582Wz2TR9+nSrbMWKFWrfvr0CAwNVvXp13XLLLfrrX/8q6efnCW+//XZJUr9+/axYzj+ztG/fPiUmJiosLEx+fn6qU6eOevfurby8vHKfNyoHZn5QaeXl5emHH35wKqtVq5Y2bdqkL774Qr1791adOnV04MABTZ8+XZ06ddKuXbtUtWrVMvv74Ycf9Nvf/lbHjx/X2rVrVb9+fZWUlOj+++/Xhg0bNGjQIDVu3Fjbt2/XpEmTtHfvXi1ZsuSC8T377LPKy8vTf//7X02aNEmSVL16dUm67H5ff/11rVq1SsnJycrIyJC3t7feeust/fvf/9bcuXMVERGhO++8U0OHDtWUKVP017/+VY0bN5YkNW7cWMeOHdPdd9+t2rVra8SIEQoMDNSBAwf04YcfXuXoA0DlsHTpUtWrV08dOnQos/7OO+9UvXr19Mknn5Sq69Wrlxo2bKiXXnpJF3un/MMPP6yFCxeqb9++atOmjdauXatu3bpddozffvutHnjgAQ0YMEDJycn6xz/+oYcfflixsbGKiYmRJH333XdasmSJevXqpejoaOXk5Oitt95Sx44dtWvXLkVERFz28S52XZGkuXPnKjk5WQkJCZowYYJOnTql6dOnq3379tq6davq1aunzp076/HHH1daWpp69Oihli1b6vvvv9eQIUMUHx+vRx99VNLPz1rde++9uu222zRu3DjZ7XZ9++23+vzzz61jjhs3TqNHj9agQYOsf09t27bVmTNnlJCQoKKiIg0ZMkRhYWE6cuSIli1bptzcXDkcjss+Z1QiBqhkZs2aZSSVuRljzKlTp0rtk5GRYSSZd999t1Q/mzZtMt9//72JiYkxN910kzlw4IDVZu7cucbLy8usX7/eqb8ZM2YYSebzzz+/aKzdunUzdevWLVVenn6XL19uJJnx48eb7777zlSvXt306NHDab9FixYZSWb16tVO5YsXL7bOEQDgLDc310gy3bt3v2i7+++/30gy+fn5xhhjxowZYySZPn36lGp7vu68rKwsI8kMGzbMqd3DDz9sJJkxY8ZYZeevS/v377fK6tataySZdevWWWXHjh0zdrvdPPnkk1ZZYWGhOXfunNMx9u/fb+x2uxk3bpxTmSQza9asi57zha4rJ06cMIGBgWbgwIFO5dnZ2cbhcDiVFxQUmAYNGpiYmBhTWFhounXrZgICAszBgwetNpMmTTKSzP/+978LxrJp06YyY966dauRZBYtWnTRc4Fn4bY3VFpTp07VihUrnDZJ8vf3t9oUFxfrxx9/VIMGDRQYGKgtW7aU6ue///2vOnbsqOLiYq1bt05169a16hYtWqTGjRurUaNG+uGHH6ytc+fOkqTVq1dfUezl6ffuu+/WI488onHjxqlnz57y8/PTW2+9dVnHCQwMlCQtW7ZMxcXFVxQrAFRWJ06ckCTVqFHjou3O1+fn5zuVn5+9uJj09HRJ0uOPP+5UPmTIkMuOs0mTJk4zU7Vr19Ytt9yi7777ziqz2+3y8vr5Z9+5c+f0448/WreQlXXtu1IrVqxQbm6u+vTp43T98vb2VuvWrZ2uX1WrVtXs2bO1e/du3Xnnnfrkk080adIkRUVFWW3OX6c++ugjlZSUlCuW8zM7y5cv16lTp67+5FApcNsbKq077rijzAUPTp8+rbS0NM2aNUtHjhxxuhWhrHuA+/btKx8fH+3evVthYWFOdfv27dPu3btL3Qd+3rFjx64o9vL2++qrr+qjjz7Stm3bNH/+fIWEhFzWcTp27KjExESNHTtWkyZNUqdOndSjRw/98Y9/vC5WEwIAdzqf1JxPgi7kQknSr1ccLcvBgwfl5eVVqm2DBg0uO85fJgvn1axZUz/99JP1uaSkRK+//rqmTZum/fv369y5c1ZdcHDwZR/rUvbt2ydJ1h/rfi0gIMDpc7t27fTYY49p6tSpSkhIKPXM6R/+8Af9/e9/15///GeNGDFCXbp0Uc+ePfXAAw9YydyFREdHKzU1VRMnTtS8efPUoUMH3X///XrooYe45c2DkfzA4wwZMkSzZs3SsGHDFBcXJ4fDIZvNpt69e5f5V6WePXvq3Xff1euvv660tDSnupKSEjVt2lQTJ04s81iRkZFXFGN5+926dauVEG3fvl19+vS5rOPYbDZ98MEH2rhxo5YuXarly5erf//+eu2117Rx40brGSQA8EQOh0Ph4eH6+uuvL9ru66+/1m9+85tSP+x/eadBRbrQCnC//OPeSy+9pFGjRql///564YUXFBQUJC8vLw0bNqzcMyoXc76vuXPnlvqDoaRSK90VFRVZCyX85z//0alTp5yevfX399e6deu0evVqffLJJ0pPT9f777+vzp0769///vclV7977bXX9PDDD+ujjz7Sv//9bw0dOlRpaWnauHGj6tSpc5VnixsRyQ88zgcffKDk5GS99tprVllhYaFyc3PLbD9kyBA1aNBAo0ePlsPhcHo/Q/369fXVV1+pS5cuV/TG7gvtU55+CwoK1K9fPzVp0kRt27bVK6+8ot///vfW6jcXO855bdq0UZs2bfTiiy9q/vz5SkpK0oIFC/TnP/+53OcEAJXJvffeq7ffflsbNmywVmz7pfXr1+vAgQN65JFHrqj/unXrqqSkRPv371fDhg2t8m+//faKYy7LBx98oLvuukvvvPOOU3lubq5q1apV7v4udv2SpJCQEMXHx1+ynzFjxmj37t169dVX9cwzz2jEiBGaMmWKUxsvLy916dJFXbp00cSJE/XSSy/p2Wef1erVqxUfH3/Ja1zTpk3VtGlTPffcc/riiy/Url07zZgxQ+PHj7/Ms0VlwjM/8Dje3t6lVt154403nG4B+LVRo0bpL3/5i0aOHOm0/OaDDz6oI0eO6O233y61z+nTp1VQUHDRWKpVq1bmrXbl6feZZ57RoUOHNGfOHE2cOFH16tVTcnKy05LY1apVk6RSCd5PP/1UaizOvyDuUkt1A4AneOqpp+Tv769HHnlEP/74o1Pd8ePH9eijj6pq1ap66qmnrqj/hIQESdK0adOcyt94440rC/gCyrr2LVq0SEeOHLmi/i50XUlISFBAQIBeeumlMp8l/d///mf9c2Zmpl599VUNGzZMTz75pJ566im9+eabWrt2rdXm+PHjpfr49XXqQrHk5+fr7NmzTmVNmzaVl5cX1zgPxswPPM69996ruXPnyuFwqEmTJsrIyNBnn312yXue//a3vykvL08pKSmqUaOGHnroIfXt21cLFy7Uo48+qtWrV6tdu3Y6d+6cvvnmGy1cuFDLly+/6ItWY2Nj9f777ys1NVW33367qlevrvvuu++y+121apWmTZumMWPGqGXLlpKkWbNmqVOnTho1apT13onmzZvL29tbEyZMUF5enux2uzp37qz58+dr2rRp+v3vf6/69evrxIkTevvttxUQEKB77rnHdYMOADeohg0bas6cOUpKSlLTpk01YMAARUdH68CBA3rnnXf0ww8/6L333rNmPMorNjZWiYmJmjx5sn788Udrqeu9e/dKuvTM/eW69957NW7cOPXr109t27bV9u3bNW/evIu+mPViLnRdCQkJ0fTp09W3b1+1bNlSvXv3Vu3atXXo0CF98sknateund58800VFhYqOTlZDRs21IsvvihJGjt2rJYuXap+/fpp+/btqlatmsaNG6d169apW7duqlu3ro4dO6Zp06apTp061kxc/fr1FRgYqBkzZqhGjRqqVq2aWrdura+++kqDBw9Wr169dPPNN+vs2bOaO3euvL29lZiY6JJxxQ3IrWvNARXgl0tUl+Wnn34y/fr1M7Vq1TLVq1c3CQkJ5ptvvjF169Y1ycnJF+3n3Llzpk+fPsbHx8csWbLEGGPMmTNnzIQJE0xMTIyx2+2mZs2aJjY21owdO9bk5eVdNNaTJ0+aP/7xjyYwMNBIclr2+lL95ufnm7p165qWLVua4uJip36HDx9uvLy8TEZGhlX29ttvm5tuusl4e3tby5Nu2bLF9OnTx0RFRRm73W5CQkLMvffeazZv3ny5ww0AHuHrr782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OBxmzZo15vvvv7e2U6dOWW0effRRExUVZVatWmU2b95s4uLiTFxcnFV/fqnQu+++22zbts2kp6eb2rVrl7kM8VNPPWV2795tpk6desMuQzxixAizdu1as3//fvP111+bESNGGJvNZv79738bYxivy/HLFZmMYcw8hadfny7kWn0Pe4KK+G6prL788kvj4+NjXnzxRbNv3z4zb948U7VqVfPPf/7TauOK30yVUXJysvnNb35jLXX94Ycfmlq1apmnn37aanO9jJ1HJD/GGPPGG2+YqKgo4+vra+644w6zceNGd4d0zaxevdpIKrUlJycbY35efnDUqFEmNDTU2O1206VLF7Nnzx6nPn788UfTp08fU716dRMQEGD69etnTpw44dTmq6++Mu3btzd2u9385je/MS+//PK1OkWXKmusJJlZs2ZZbU6fPm0ef/xxU7NmTVO1alXz+9//3nz//fdO/Rw4cMB07drV+Pv7m1q1apknn3zSFBcXO7VZvXq1ad68ufH19TU33XST0zFuJP379zd169Y1vr6+pnbt2qZLly5W4mMM43U5fv0DhTHzHJ58fbqQa/k9XNlV1HdLZbV06VJz6623Grvdbho1amRmzpzpVO+q30yVTX5+vnniiSdMVFSU8fPzMzfddJN59tlnnZZHv17GzmbML169CgAAAACVVKV/5gcAAAAAJJIfAAAAAB6C5AcAAACARyD5AQAAAOARSH4AAAAAeASSHwAAAAAegeQHAAAAgEcg+QEAAADgEUh+AAAAAHgEkh8AAAAAHoHkBwAAAIBH+P8AZWkfmGeB+9AAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 1000x400 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this is a sample text for cleaning \n",
      "sample text lemmatization cleaning\n",
      "Logistic Regression with TF-IDF\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           0       0.55      0.63      0.59        68\n",
      "           1       0.57      0.49      0.52        68\n",
      "\n",
      "    accuracy                           0.56       136\n",
      "   macro avg       0.56      0.56      0.56       136\n",
      "weighted avg       0.56      0.56      0.56       136\n",
      "\n",
      "Confusion Matrix: [[43 25]\n",
      " [35 33]]\n",
      "AUC: 0.5637975778546713\n",
      "\n",
      "Naive Bayes with TF-IDF\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "           0       0.06      0.01      0.02        68\n",
      "           1       0.44      0.78      0.56        68\n",
      "\n",
      "    accuracy                           0.40       136\n",
      "   macro avg       0.25      0.40      0.29       136\n",
      "weighted avg       0.25      0.40      0.29       136\n",
      "\n",
      "Confusion Matrix: [[ 1 67]\n",
      " [15 53]]\n",
      "AUC: 0.29952422145328716\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Lukag\\AppData\\Local\\Temp\\ipykernel_5620\\3988082522.py:118: SyntaxWarning: invalid escape sequence '\\s'\n",
      "  text = re.sub('\\s+', ' ', text)\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "Negative values in data passed to MultinomialNB (input X)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[1], line 334\u001b[0m\n\u001b[0;32m    330\u001b[0m     roc_auc_rf \u001b[38;5;241m=\u001b[39m auc(fpr_rf, tpr_rf)\n\u001b[0;32m    331\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mAUC:\u001b[39m\u001b[38;5;124m\"\u001b[39m, roc_auc_rf)\n\u001b[1;32m--> 334\u001b[0m \u001b[43manalysis_of_cleaned_texts\u001b[49m\u001b[43m(\u001b[49m\u001b[43mdf_train\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43msubmission.csv\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[0;32m    335\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m Second part with ngrams\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m    336\u001b[0m analysis_of_cleaned_texts(df_train, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124msubmission.csv\u001b[39m\u001b[38;5;124m'\u001b[39m, ngrams\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n",
      "Cell \u001b[1;32mIn[1], line 251\u001b[0m, in \u001b[0;36manalysis_of_cleaned_texts\u001b[1;34m(df, filename, ngrams)\u001b[0m\n\u001b[0;32m    249\u001b[0m \u001b[38;5;66;03m# Naive Bayes with Word2Vec\u001b[39;00m\n\u001b[0;32m    250\u001b[0m nb_tfidf \u001b[38;5;241m=\u001b[39m MultinomialNB()\n\u001b[1;32m--> 251\u001b[0m \u001b[43mnb_tfidf\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfit\u001b[49m\u001b[43m(\u001b[49m\u001b[43mX_train_vectors_w2v\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43my_train\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    252\u001b[0m y_predict \u001b[38;5;241m=\u001b[39m nb_tfidf\u001b[38;5;241m.\u001b[39mpredict(X_val_vectors_w2v)\n\u001b[0;32m    253\u001b[0m y_prob \u001b[38;5;241m=\u001b[39m nb_tfidf\u001b[38;5;241m.\u001b[39mpredict_proba(X_val_vectors_w2v)[:, \u001b[38;5;241m1\u001b[39m]\n",
      "File \u001b[1;32mc:\\Users\\Lukag\\miniconda3\\Lib\\site-packages\\sklearn\\base.py:1473\u001b[0m, in \u001b[0;36m_fit_context.<locals>.decorator.<locals>.wrapper\u001b[1;34m(estimator, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1466\u001b[0m     estimator\u001b[38;5;241m.\u001b[39m_validate_params()\n\u001b[0;32m   1468\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m config_context(\n\u001b[0;32m   1469\u001b[0m     skip_parameter_validation\u001b[38;5;241m=\u001b[39m(\n\u001b[0;32m   1470\u001b[0m         prefer_skip_nested_validation \u001b[38;5;129;01mor\u001b[39;00m global_skip_validation\n\u001b[0;32m   1471\u001b[0m     )\n\u001b[0;32m   1472\u001b[0m ):\n\u001b[1;32m-> 1473\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mfit_method\u001b[49m\u001b[43m(\u001b[49m\u001b[43mestimator\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32mc:\\Users\\Lukag\\miniconda3\\Lib\\site-packages\\sklearn\\naive_bayes.py:759\u001b[0m, in \u001b[0;36m_BaseDiscreteNB.fit\u001b[1;34m(self, X, y, sample_weight)\u001b[0m\n\u001b[0;32m    757\u001b[0m n_classes \u001b[38;5;241m=\u001b[39m Y\u001b[38;5;241m.\u001b[39mshape[\u001b[38;5;241m1\u001b[39m]\n\u001b[0;32m    758\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_init_counters(n_classes, n_features)\n\u001b[1;32m--> 759\u001b[0m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_count\u001b[49m\u001b[43m(\u001b[49m\u001b[43mX\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mY\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    760\u001b[0m alpha \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_check_alpha()\n\u001b[0;32m    761\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_update_feature_log_prob(alpha)\n",
      "File \u001b[1;32mc:\\Users\\Lukag\\miniconda3\\Lib\\site-packages\\sklearn\\naive_bayes.py:881\u001b[0m, in \u001b[0;36mMultinomialNB._count\u001b[1;34m(self, X, Y)\u001b[0m\n\u001b[0;32m    879\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_count\u001b[39m(\u001b[38;5;28mself\u001b[39m, X, Y):\n\u001b[0;32m    880\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"Count and smooth feature occurrences.\"\"\"\u001b[39;00m\n\u001b[1;32m--> 881\u001b[0m     \u001b[43mcheck_non_negative\u001b[49m\u001b[43m(\u001b[49m\u001b[43mX\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mMultinomialNB (input X)\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[0;32m    882\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfeature_count_ \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m safe_sparse_dot(Y\u001b[38;5;241m.\u001b[39mT, X)\n\u001b[0;32m    883\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mclass_count_ \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m Y\u001b[38;5;241m.\u001b[39msum(axis\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m0\u001b[39m)\n",
      "File \u001b[1;32mc:\\Users\\Lukag\\miniconda3\\Lib\\site-packages\\sklearn\\utils\\validation.py:1689\u001b[0m, in \u001b[0;36mcheck_non_negative\u001b[1;34m(X, whom)\u001b[0m\n\u001b[0;32m   1686\u001b[0m     X_min \u001b[38;5;241m=\u001b[39m xp\u001b[38;5;241m.\u001b[39mmin(X)\n\u001b[0;32m   1688\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m X_min \u001b[38;5;241m<\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[1;32m-> 1689\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mNegative values in data passed to \u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[38;5;124m\"\u001b[39m \u001b[38;5;241m%\u001b[39m whom)\n",
      "\u001b[1;31mValueError\u001b[0m: Negative values in data passed to MultinomialNB (input X)"
     ]
    }
   ],
   "source": [
    "import re\n",
    "import string\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import nltk\n",
    "\n",
    "from nltk.tokenize import word_tokenize\n",
    "from nltk.corpus import stopwords, wordnet\n",
    "from nltk.stem import WordNetLemmatizer\n",
    "\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.naive_bayes import MultinomialNB\n",
    "from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "\n",
    "from gensim.models import Word2Vec\n",
    "from nltk.util import ngrams\n",
    "\n",
    "# Download required NLTK resources\n",
    "nltk.download('punkt')\n",
    "nltk.download('averaged_perceptron_tagger')\n",
    "nltk.download('wordnet')\n",
    "nltk.download('stopwords')\n",
    "\n",
    "\n",
    "class TextClassifier:\n",
    "    \"\"\"\n",
    "    A class to preprocess text data, build vector representations (TF-IDF and Word2Vec),\n",
    "    and train/evaluate several classifiers on any given dataset.\n",
    "    \n",
    "    Additional parameters can be set via arguments.\n",
    "    \"\"\"\n",
    "\n",
    "    class MeanEmbeddingVectorizer:\n",
    "        \"\"\"\n",
    "        Helper class to compute a mean embedding for a list of tokens using a given Word2Vec model.\n",
    "        \"\"\"\n",
    "        def __init__(self, word2vec):\n",
    "            self.word2vec = word2vec\n",
    "            self.dim = len(next(iter(word2vec.values())))\n",
    "\n",
    "        def fit(self, X, y=None):\n",
    "            return self\n",
    "\n",
    "        def transform(self, X):\n",
    "            return np.array([\n",
    "                np.mean([self.word2vec[w] for w in words if w in self.word2vec]\n",
    "                        or [np.zeros(self.dim)], axis=0)\n",
    "                for words in X\n",
    "            ])\n",
    "\n",
    "    def __init__(self,\n",
    "                 df,\n",
    "                 text_column='text',\n",
    "                 target_column='target',\n",
    "                 use_ngrams=False,\n",
    "                 test_size=0.2,\n",
    "                 random_state=42,\n",
    "                 tfidf_params=None,\n",
    "                 lr_params=None,\n",
    "                 rf_params=None,\n",
    "                 w2v_params=None):\n",
    "        \"\"\"\n",
    "        Initialize the classifier with a pandas DataFrame and various hyperparameters.\n",
    "        \n",
    "        Parameters:\n",
    "          - df: pandas DataFrame containing the data.\n",
    "          - text_column: column name for raw text (default: 'text').\n",
    "          - target_column: column name for target labels (default: 'target').\n",
    "          - use_ngrams: whether to add bigrams and trigrams during tokenization (default: False).\n",
    "          - test_size: proportion of data to use for validation (default: 0.2).\n",
    "          - random_state: seed for train-test split and models (default: 42).\n",
    "          - tfidf_params: dict of parameters for TfidfVectorizer (default: {'use_idf': True}).\n",
    "          - lr_params: dict of parameters for LogisticRegression (default: {'solver': 'liblinear', 'C': 10, 'penalty': 'l1'}).\n",
    "          - rf_params: dict of parameters for RandomForestClassifier (default: {'n_estimators': 100, 'random_state': random_state}).\n",
    "          - w2v_params: dict of parameters for Word2Vec model (default: {'min_count': 1}).\n",
    "        \"\"\"\n",
    "        self.df = df.copy()\n",
    "        self.text_column = text_column\n",
    "        self.target_column = target_column\n",
    "        self.use_ngrams = use_ngrams\n",
    "        self.test_size = test_size\n",
    "        self.random_state = random_state\n",
    "\n",
    "        # Set default parameters if None provided\n",
    "        self.tfidf_params = tfidf_params if tfidf_params is not None else {'use_idf': True}\n",
    "        self.lr_params = lr_params if lr_params is not None else {'solver': 'liblinear', 'C': 10, 'penalty': 'l1'}\n",
    "        self.rf_params = rf_params if rf_params is not None else {'n_estimators': 100, 'random_state': self.random_state}\n",
    "        self.w2v_params = w2v_params if w2v_params is not None else {'min_count': 1}\n",
    "\n",
    "        # Preprocess the text data\n",
    "        self.df['clean_text'] = self.df[self.text_column].apply(self.finalpreprocess)\n",
    "\n",
    "        # Tokenize for Word2Vec\n",
    "        self.df['clean_text_tok'] = self.df['clean_text'].apply(word_tokenize)\n",
    "\n",
    "        # Train a Word2Vec model on the tokenized clean text\n",
    "        self.w2v_model = Word2Vec(self.df['clean_text_tok'], **self.w2v_params)\n",
    "        self.w2v = dict(zip(self.w2v_model.wv.index_to_key, self.w2v_model.wv.vectors))\n",
    "        self.mean_embedding_vectorizer = self.MeanEmbeddingVectorizer(self.w2v)\n",
    "\n",
    "    def preprocess(self, text):\n",
    "        \"\"\"\n",
    "        Basic text cleaning: lowercasing, removal of HTML tags, punctuation, extra whitespace, and numbers.\n",
    "        \"\"\"\n",
    "        text = text.lower().strip()\n",
    "        text = re.sub('<.*?>', '', text)\n",
    "        text = re.compile('[%s]' % re.escape(string.punctuation)).sub(' ', text)\n",
    "        text = re.sub('\\s+', ' ', text)\n",
    "        text = re.sub(r'\\[[0-9]*\\]', ' ', text)\n",
    "        text = re.sub(r'[^\\w\\s]', '', text)\n",
    "        text = re.sub(r'\\d', ' ', text)\n",
    "        text = re.sub(r'\\s+', ' ', text)\n",
    "        return text\n",
    "\n",
    "    def stopword_removal(self, text):\n",
    "        \"\"\"\n",
    "        Remove English stopwords.\n",
    "        \"\"\"\n",
    "        return ' '.join([word for word in text.split() if word not in stopwords.words('english')])\n",
    "\n",
    "    def lemmatizer(self, text):\n",
    "        \"\"\"\n",
    "        Lemmatize the text using NLTK's WordNetLemmatizer with POS tagging.\n",
    "        \"\"\"\n",
    "        lemmatizer = WordNetLemmatizer()\n",
    "\n",
    "        def get_wordnet_pos(tag):\n",
    "            if tag.startswith('J'):\n",
    "                return wordnet.ADJ\n",
    "            elif tag.startswith('V'):\n",
    "                return wordnet.VERB\n",
    "            elif tag.startswith('N'):\n",
    "                return wordnet.NOUN\n",
    "            elif tag.startswith('R'):\n",
    "                return wordnet.ADV\n",
    "            else:\n",
    "                return wordnet.NOUN\n",
    "\n",
    "        word_pos_tags = nltk.pos_tag(word_tokenize(text))\n",
    "        lemmatized = [lemmatizer.lemmatize(word, get_wordnet_pos(tag)) for word, tag in word_pos_tags]\n",
    "        return ' '.join(lemmatized)\n",
    "\n",
    "    def finalpreprocess(self, text):\n",
    "        \"\"\"\n",
    "        Apply the full preprocessing pipeline: cleaning, stopword removal, and lemmatization.\n",
    "        \"\"\"\n",
    "        text = self.preprocess(text)\n",
    "        text = self.stopword_removal(text)\n",
    "        text = self.lemmatizer(text)\n",
    "        return text\n",
    "\n",
    "    def add_ngrams(self, tokens, n=3):\n",
    "        \"\"\"\n",
    "        Generate bigrams and trigrams from a list of tokens and return the tokens combined with these n-grams.\n",
    "        \"\"\"\n",
    "        bigrams = list(ngrams(tokens, 2))\n",
    "        trigrams = list(ngrams(tokens, 3))\n",
    "        bigrams = ['_'.join(bigram) for bigram in bigrams]\n",
    "        trigrams = ['_'.join(trigram) for trigram in trigrams]\n",
    "        return tokens + bigrams + trigrams\n",
    "\n",
    "    def run_analysis(self):\n",
    "        \"\"\"\n",
    "        Split the dataset, generate feature representations, train several classifiers,\n",
    "        and print evaluation metrics.\n",
    "        \"\"\"\n",
    "        # Split dataset into training and validation sets\n",
    "        X_train, X_val, y_train, y_val = train_test_split(\n",
    "            self.df['clean_text'], self.df[self.target_column],\n",
    "            test_size=self.test_size, shuffle=True, random_state=self.random_state\n",
    "        )\n",
    "\n",
    "        # Tokenize texts for Word2Vec transformation.\n",
    "        # Optionally add n-grams if specified.\n",
    "        if self.use_ngrams:\n",
    "            X_train_tok = [self.add_ngrams(word_tokenize(text)) for text in X_train]\n",
    "            X_val_tok = [self.add_ngrams(word_tokenize(text)) for text in X_val]\n",
    "        else:\n",
    "            X_train_tok = [word_tokenize(text) for text in X_train]\n",
    "            X_val_tok = [word_tokenize(text) for text in X_val]\n",
    "\n",
    "        # TF-IDF Vectorization on the clean text using passed parameters\n",
    "        tfidf_vectorizer = TfidfVectorizer(**self.tfidf_params)\n",
    "        X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)\n",
    "        X_val_tfidf = tfidf_vectorizer.transform(X_val)\n",
    "\n",
    "        # Word2Vec transformation using the mean embedding\n",
    "        X_train_w2v = self.mean_embedding_vectorizer.transform(X_train_tok)\n",
    "        X_val_w2v = self.mean_embedding_vectorizer.transform(X_val_tok)\n",
    "\n",
    "        # ----- Logistic Regression with TF-IDF -----\n",
    "        lr_tfidf = LogisticRegression(**self.lr_params)\n",
    "        lr_tfidf.fit(X_train_tfidf, y_train)\n",
    "        y_pred = lr_tfidf.predict(X_val_tfidf)\n",
    "        y_prob = lr_tfidf.predict_proba(X_val_tfidf)[:, 1]\n",
    "        print(\"Logistic Regression with TF-IDF\")\n",
    "        print(classification_report(y_val, y_pred))\n",
    "        print(\"Confusion Matrix:\\n\", confusion_matrix(y_val, y_pred))\n",
    "        fpr, tpr, _ = roc_curve(y_val, y_prob)\n",
    "        print(\"AUC:\", auc(fpr, tpr))\n",
    "\n",
    "        # ----- Naive Bayes with TF-IDF -----\n",
    "        nb_tfidf = MultinomialNB()\n",
    "        nb_tfidf.fit(X_train_tfidf, y_train)\n",
    "        y_pred = nb_tfidf.predict(X_val_tfidf)\n",
    "        y_prob = nb_tfidf.predict_proba(X_val_tfidf)[:, 1]\n",
    "        print(\"\\nNaive Bayes with TF-IDF\")\n",
    "        print(classification_report(y_val, y_pred))\n",
    "        print(\"Confusion Matrix:\\n\", confusion_matrix(y_val, y_pred))\n",
    "        fpr, tpr, _ = roc_curve(y_val, y_prob)\n",
    "        print(\"AUC:\", auc(fpr, tpr))\n",
    "\n",
    "        # ----- Logistic Regression with Word2Vec -----\n",
    "        lr_w2v = LogisticRegression(**self.lr_params)\n",
    "        lr_w2v.fit(X_train_w2v, y_train)\n",
    "        y_pred = lr_w2v.predict(X_val_w2v)\n",
    "        y_prob = lr_w2v.predict_proba(X_val_w2v)[:, 1]\n",
    "        print(\"\\nLogistic Regression with Word2Vec\")\n",
    "        print(classification_report(y_val, y_pred))\n",
    "        print(\"Confusion Matrix:\\n\", confusion_matrix(y_val, y_pred))\n",
    "        fpr, tpr, _ = roc_curve(y_val, y_prob)\n",
    "        print(\"AUC:\", auc(fpr, tpr))\n",
    "\n",
    "        # ----- Random Forest with Word2Vec -----\n",
    "        rf_w2v = RandomForestClassifier(**self.rf_params)\n",
    "        rf_w2v.fit(X_train_w2v, y_train)\n",
    "        y_pred = rf_w2v.predict(X_val_w2v)\n",
    "        y_prob = rf_w2v.predict_proba(X_val_w2v)[:, 1]\n",
    "        print(\"\\nRandom Forest with Word2Vec\")\n",
    "        print(classification_report(y_val, y_pred))\n",
    "        print(\"Confusion Matrix:\\n\", confusion_matrix(y_val, y_pred))\n",
    "        fpr, tpr, _ = roc_curve(y_val, y_prob)\n",
    "        print(\"AUC:\", auc(fpr, tpr))\n",
    "\n",
    "        # ----- Random Forest with TF-IDF -----\n",
    "        rf = RandomForestClassifier(**self.rf_params)\n",
    "        rf.fit(X_train_tfidf, y_train)\n",
    "        y_pred = rf.predict(X_val_tfidf)\n",
    "        y_prob = rf.predict_proba(X_val_tfidf)[:, 1]\n",
    "        print(\"\\nRandom Forest with TF-IDF\")\n",
    "        print(classification_report(y_val, y_pred))\n",
    "        print(\"Confusion Matrix:\\n\", confusion_matrix(y_val, y_pred))\n",
    "        fpr, tpr, _ = roc_curve(y_val, y_prob)\n",
    "        print(\"AUC:\", auc(fpr, tpr))\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
